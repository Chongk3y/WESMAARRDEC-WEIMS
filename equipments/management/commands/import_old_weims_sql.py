import re
import os
from django.core.management.base import BaseCommand
from django.db import connection

class Command(BaseCommand):
    help = 'Analyze and modify old WEIMS SQL file for import into integrated system'
    
    def add_arguments(self, parser):
        parser.add_argument(
            '--input-sql',
            type=str,
            required=True,
            help='Path to the old WEIMS SQL file'
        )
        parser.add_argument(
            '--output-sql',
            type=str,
            help='Path for the modified SQL file (default: modified_weims_import.sql)'
        )
        parser.add_argument(
            '--analyze-only',
            action='store_true',
            help='Only analyze the SQL file structure without creating modified version'
        )

    def handle(self, *args, **options):
        input_file = options['input_sql']
        output_file = options.get('output_sql', 'modified_weims_import.sql')
        
        if not os.path.exists(input_file):
            self.stdout.write(
                self.style.ERROR(f'Input SQL file not found: {input_file}')
            )
            return

        # Read the SQL file
        with open(input_file, 'r', encoding='utf-8') as f:
            sql_content = f.read()

        # Analyze the structure
        self.analyze_sql_structure(sql_content)
        
        if not options['analyze_only']:
            # Modify the SQL for the new system
            modified_sql = self.modify_sql_for_integration(sql_content)
            
            # Write the modified SQL
            with open(output_file, 'w', encoding='utf-8') as f:
                f.write(modified_sql)
            
            self.stdout.write(
                self.style.SUCCESS(f'Modified SQL written to: {output_file}')
            )
            
            # Provide import instructions
            self.show_import_instructions(output_file)

    def analyze_sql_structure(self, sql_content):
        """Analyze the structure of the old WEIMS SQL file"""
        self.stdout.write(self.style.WARNING('=== ANALYZING OLD WEIMS SQL STRUCTURE ==='))
        
        # Find table creation statements
        table_pattern = r'CREATE TABLE\s+`?(\w+)`?\s*\('
        tables = re.findall(table_pattern, sql_content, re.IGNORECASE)
        
        self.stdout.write(f'Found {len(tables)} tables:')
        for table in tables:
            self.stdout.write(f'  - {table}')
        
        # Analyze equipment-related tables
        equipment_tables = [t for t in tables if 'equipment' in t.lower() or 'category' in t.lower() or 'status' in t.lower()]
        
        self.stdout.write('\nEquipment-related tables:')
        for table in equipment_tables:
            self.stdout.write(f'  - {table}')
            self.analyze_table_structure(sql_content, table)

    def analyze_table_structure(self, sql_content, table_name):
        """Analyze the structure of a specific table"""
        # Extract table definition
        pattern = rf'CREATE TABLE\s+`?{re.escape(table_name)}`?\s*\((.*?)\);'
        match = re.search(pattern, sql_content, re.IGNORECASE | re.DOTALL)
        
        if match:
            table_def = match.group(1)
            # Extract column definitions
            columns = re.findall(r'`?(\w+)`?\s+(\w+(?:\(\d+\))?)', table_def)
            self.stdout.write(f'    Columns:')
            for col_name, col_type in columns[:10]:  # Show first 10 columns
                self.stdout.write(f'      {col_name}: {col_type}')
            if len(columns) > 10:
                self.stdout.write(f'      ... and {len(columns) - 10} more columns')

    def modify_sql_for_integration(self, sql_content):
        """Modify the SQL content to work with the integrated system"""
        self.stdout.write(self.style.WARNING('=== MODIFYING SQL FOR INTEGRATION ==='))
        
        modified_sql = []
        modified_sql.append("-- Modified WEIMS SQL for Django Integration")
        modified_sql.append("-- Generated by import_old_weims_sql command")
        modified_sql.append("-- Make sure to backup your current database before running this!")
        modified_sql.append("")
        
        # Add foreign key constraint disabling (for import)
        modified_sql.append("SET FOREIGN_KEY_CHECKS = 0;")
        modified_sql.append("")
        
        # Get current Django table structure
        django_tables = self.get_django_table_structure()
        
        # Process each relevant table
        tables_to_process = ['equipment', 'category', 'status']
        
        for table in tables_to_process:
            table_sql = self.extract_and_modify_table(sql_content, table, django_tables)
            if table_sql:
                modified_sql.append(table_sql)
                modified_sql.append("")
        
        # Re-enable foreign key checks
        modified_sql.append("SET FOREIGN_KEY_CHECKS = 1;")
        
        return "\n".join(modified_sql)

    def get_django_table_structure(self):
        """Get the current Django database table structure"""
        with connection.cursor() as cursor:
            # Get equipments table structure
            cursor.execute("DESCRIBE equipments_equipment;")
            equipment_columns = {row[0]: row[1] for row in cursor.fetchall()}
            
            cursor.execute("DESCRIBE equipments_category;")
            category_columns = {row[0]: row[1] for row in cursor.fetchall()}
            
            cursor.execute("DESCRIBE equipments_status;")
            status_columns = {row[0]: row[1] for row in cursor.fetchall()}
        
        return {
            'equipment': equipment_columns,
            'category': category_columns,
            'status': status_columns
        }

    def extract_and_modify_table(self, sql_content, table_type, django_tables):
        """Extract and modify a specific table type"""
        self.stdout.write(f'Processing {table_type} table...')
        
        # Map old table names to new Django table names
        table_mapping = {
            'equipment': 'equipments_equipment',
            'category': 'equipments_category', 
            'status': 'equipments_status'
        }
        
        django_table = table_mapping.get(table_type)
        if not django_table:
            return None
        
        # Find old table name in SQL (could be various names)
        old_table_patterns = {
            'equipment': [r'equipment[s]?', r'item[s]?', r'asset[s]?'],
            'category': [r'categor[yi][es]*', r'type[s]?'],
            'status': [r'status[es]*', r'state[s]?']
        }
        
        patterns = old_table_patterns.get(table_type, [table_type])
        
        for pattern in patterns:
            # Look for INSERT statements
            insert_pattern = rf'INSERT INTO\s+`?({pattern})`?\s*\([^)]*\)\s*VALUES\s*(.*?);'
            matches = re.findall(insert_pattern, sql_content, re.IGNORECASE | re.DOTALL)
            
            if matches:
                return self.create_modified_insert(table_type, django_table, matches, django_tables)
        
        self.stdout.write(f'  No {table_type} data found in SQL file')
        return None

    def create_modified_insert(self, table_type, django_table, matches, django_tables):
        """Create modified INSERT statements"""
        modified_inserts = []
        modified_inserts.append(f"-- {table_type.upper()} DATA")
        
        if table_type == 'category':
            modified_inserts.append(f"INSERT INTO {django_table} (name) VALUES")
            # Extract category names and create simple inserts
            values = []
            for old_table, data in matches:
                # Parse the values - this is simplified and may need adjustment
                value_matches = re.findall(r'\([^)]+\)', data)
                for value in value_matches[:5]:  # Limit for example
                    # Extract the category name (usually first or second field)
                    name_match = re.search(r"'([^']+)'", value)
                    if name_match:
                        values.append(f"('{name_match.group(1)}')")
            
            if values:
                modified_inserts.append(",\n".join(values) + ";")
        
        elif table_type == 'status':
            modified_inserts.append(f"INSERT INTO {django_table} (name) VALUES")
            # Similar processing for status
            values = []
            for old_table, data in matches:
                value_matches = re.findall(r'\([^)]+\)', data)
                for value in value_matches[:5]:
                    name_match = re.search(r"'([^']+)'", value)
                    if name_match:
                        values.append(f"('{name_match.group(1)}')")
            
            if values:
                modified_inserts.append(",\n".join(values) + ";")
        
        elif table_type == 'equipment':
            # This is more complex - equipment table has many fields
            modified_inserts.append("-- Equipment data requires manual mapping")
            modified_inserts.append("-- Please provide the exact structure of your old equipment table")
            modified_inserts.append(f"-- Target table: {django_table}")
            modified_inserts.append("-- Target columns: " + ", ".join(django_tables.get('equipment', {}).keys()))
        
        return "\n".join(modified_inserts)

    def show_import_instructions(self, output_file):
        """Show instructions for importing the modified SQL"""
        self.stdout.write(self.style.SUCCESS('\n=== IMPORT INSTRUCTIONS ==='))
        self.stdout.write('1. Backup your current database:')
        self.stdout.write('   mysqldump -u root -p wesmaarrdecdb > backup_before_import.sql')
        
        self.stdout.write('\n2. Review the modified SQL file:')
        self.stdout.write(f'   Check the content of {output_file}')
        
        self.stdout.write('\n3. Import the modified data:')
        self.stdout.write(f'   mysql -u root -p wesmaarrdecdb < {output_file}')
        
        self.stdout.write('\n4. Verify the import:')
        self.stdout.write('   python manage.py shell')
        self.stdout.write('   >>> from equipments.models import Equipment, Category, Status')
        self.stdout.write('   >>> print(f"Categories: {Category.objects.count()}")')
        self.stdout.write('   >>> print(f"Statuses: {Status.objects.count()}")')
        self.stdout.write('   >>> print(f"Equipment: {Equipment.objects.count()}")')
        
        self.stdout.write(self.style.WARNING('\nNOTE: The equipment table may need manual adjustment of field mappings!'))
